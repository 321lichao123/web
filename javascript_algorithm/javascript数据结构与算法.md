## 第14章 算法设计与技巧

### 14.2 动态规划

**什么是动态规划**

> 通过把复杂的的原问题分解为相对简单的子问题的方法

**动态规划有哪些特征**

- 重叠子问题

  子问题重复出现

- 最优子结构

  一个问题的最优解包含其子问题的最优解（也就是说子问题的最优解也就是原问题的最优解）

- 无后效性

  某阶段的状态一旦确定，则此后过程中的演变不再受此前各种状态及决策的影响

**动态规划问题的解决步骤**

- 确定子问题
- 确定状态转移方程
- 确定边界条件

#### 14.2.4 矩阵相乘

**题目：**

求矩阵p=[5, 10, 3, 12, 5]的最少乘法运算次数 ?

**分析：**

上面的数组可以换成下面的矩阵

![转换成矩阵](./img/14/矩阵的示意.png)

因此原问题求矩阵的问题可以转换为下面的子问题

![转换成子问题](./img/14/转换成子问题.png)

根据上面的表格（其实是二维数组）可以得到下面的

![根据表格得出的结论](./img/14/根据表格得出的结论.png)

有上面的结论可以得出上面的公式

![矩阵相乘公式.png](./img/14/矩阵相乘公式.png)

再次分析表格，可以得出下面的公式

![矩阵相乘斜边与横纵轴的关系.png](./img/14/矩阵相乘斜边与横纵轴的关系.png)

根据下面的表格可以得出斜边和纵轴的范围

![斜边和纵轴的范围.png](./img/14/斜边和纵轴的范围.png)

**代码：**

根据上面的分析可以写出下面的代码：

```js
const matrixChainOrder = p => {
    // 获取数组的长度
    const n = p.length
    // 定义一个数组保存项链两个矩阵的乘值
    const m = []
    // 初始化数组
    for(let i = 0; i <= n; n++) {
        m[i] = 0
        m[i][i] = 0
    }
    // 遍历斜线d
    for(let l = 2; l < n; l++) {
        // 遍历横轴
        for(let i = 0; i <= (n - l) + 1; i++) {
            // 计算纵轴
            const j = (i + l) - 1
            // 通过横纵轴遍历矩阵的分割
            for(let k = i; k <= j - 1; k++) {
                // 计算当前矩阵乘值
                const q = m[i][k - 1] + m[k][j] + (p[i - 1] * p[k] * p[j])
                // 判断当前计算出来的之是否比之前的大
                if(q < m[i][j]) {
                    // 如果比之前的大则将之前的之复制给当前的矩阵乘积
                    m[i][j] = q
                }
            }
        }
    }
    return m[1][n - 1]
}
```

### 14.3 贪心算法

**什么是贪心算法**

> 遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局

#### 14.3.1 最少硬币找零的问题

**代码**

~~~js
const minCoinChange = (coins, amount) => {
  // 用来保存适合的硬币
  let changes = []
  // 用来记录硬币的和
  let total = 0
  // 遍历硬币的种类
  for(let i = coins.length; i >= 0; i--) {
    const coin = coins[i]
    // 遍历判断当前硬币的是否符合
    while(total + coin <= amount) {
      // 如果符合添加到数组中
      changes.push(coin)
      // 对符合的硬币进行累加
      total += coin
    }
  }
  return changes
}
~~~

#### 14.3.2 分数背包问题 

**题目**：

| 物品 | 重量 | 价值 |
| :--: | :--: | :--: |
|  1   |  2   |  3   |
|  2   |  3   |  4   |
|  3   |  4   |  5   |

请问在给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。

~~~js
const knapSack = (capacity, weights, values) => {
  // 获取物品的重量和价值的长度
  let n = values.length
  // 定义一个变量保存已经添加的重量
  let load = 0
  // 定义一个变量保存已经添加的价值
  let val = 0
  // 遍历
  for(let i = 0; i < n && load < capacity; i++) {
    // 判断当前的重量是否超出限制的重量
    if(weights[i] <= capacity - load) {
      // 如果不超出则累加重量和价值
      load += weights[i]
      val += values[i]
    } else {
      // 计算剩余的重量占当前物品的重量的比例计算价值
      const r = (capacity - load) / weights[i]
      val += r * values[i]
      load += weights[i]
    }
  }
  return val
}
~~~

###  14.4 回溯算法

> 回溯是一种渐进式寻找并构建问题解决方式的策略 